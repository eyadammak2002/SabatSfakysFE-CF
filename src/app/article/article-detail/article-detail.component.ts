import { Component, OnInit, ChangeDetectorRef } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { HttpEventType, HttpResponse } from '@angular/common/http';
import { forkJoin } from 'rxjs';

import { AvisService } from 'src/app/services/avis.service';
import { PanierService } from 'src/app/services/panier.service';
import { FileUploadService } from 'src/app/services/file-upload.service';
import { Article, Couleur, Pointure } from '../article';
import { ArticleService } from '../article.service';
import { Photo } from 'src/app/photo/Photo';
import { PhotoService } from 'src/app/photo/photo.service';
import { AuthenticationService } from 'src/app/services/Authentication.service';
import { TokenStorageService } from 'src/app/services/token-storage.service';
declare var bootstrap: any;

@Component({
  selector: 'app-article-detail',
  templateUrl: './article-detail.component.html',
  styleUrls: ['./article-detail.component.css']
})
export class ArticleDetailComponent implements OnInit {
  article: Article | null = null;
  articleId: number | null = null;
  isLoading: boolean = true;
  errorMessage: string | null = null;
  
  // Pour le syst√®me de panier
  selectedCouleur: Couleur | null = null;
  selectedPointure: Pointure | null = null;
  selectedPointures: Pointure[] = [];
  
  // Pour les avis
  avis: any[] = [];
  isLoadingAvis: boolean = false;
  avisForm: FormGroup;
  avisModal: any;
  
  // Pour l'upload de photos d'avis
  selectedFiles?: FileList;
  currentFiles: File[] = [];
  progressInfos: { value: number, fileName: string }[] = [];
  uploadMessage: string = '';
  uploadSuccess: boolean = false;
  uploadError: boolean = false;
  newlyUploadedPhotos: Photo[] = [];
  isUploading: boolean = false;
  
  // Nouvelles propri√©t√©s pour g√©rer l'affichage des photos
  allPhoto: Photo[] = [];
  photosToHide: number[] = [];
  
  // Pour l'authentification
  currentClientId: number | null = null;
  currentImageIndex: number = 0;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private articleService: ArticleService,
    private panierService: PanierService,
    private avisService: AvisService,
    private authService: AuthenticationService,
    private uploadService: FileUploadService,
    private photoService: PhotoService,
    private fb: FormBuilder,
    private cdr: ChangeDetectorRef,  
    private tokenStorage: TokenStorageService
  ){
    // Initialisation du formulaire d'avis
    this.avisForm = this.fb.group({
      note: ['', Validators.required],
      description: ['', [Validators.required, Validators.minLength(10)]]
    });
  }

  ngOnInit(): void {
    // R√©cup√©rer l'ID du client si l'utilisateur est connect√©
    this.currentClientId = this.getCurrentClientId();
    console.log("currentClientId", this.currentClientId);
    
    // Charger toutes les photos disponibles
    this.getPhotos();
    
    // R√©cup√©rer l'id depuis l'URL
    this.route.paramMap.subscribe(params => {
      const id = params.get('id');
      if (id) {
        this.articleId = +id;
        this.loadArticleDetails(this.articleId);
        this.loadArticleAvis(this.articleId);
      } else {
        this.errorMessage = "Identifiant d'article non valide";
        this.isLoading = false;
      }
    });
  }
  
  // M√©thode pour v√©rifier si l'utilisateur est connect√©
  isLoggedIn(): boolean {
    const user = this.tokenStorage.getUser();
    return !!user && !!user.id;
  }
  
  // R√©cup√©rer l'ID du client connect√© si disponible
  getCurrentClientId(): number | null {
    const user = this.tokenStorage.getUser();
    console.log("user", user);
    console.log("user id", user.id);
    return user?.id || null;
  }
  
  // M√©thode pour v√©rifier si une photo est s√©lectionn√©e
  isPhotoSelected(photoId: number): boolean {
    return this.newlyUploadedPhotos.some(p => p.id === photoId);
  }
  
  // R√©cup√©rer toutes les photos depuis la base de donn√©es
  getPhotos(): void {
    this.photoService.get().subscribe({
      next: (data) => {
        this.allPhoto = data;
        console.log('Photos r√©cup√©r√©es:', this.allPhoto);

        // Si aucune photo n'a √©t√© nouvellement upload√©e, initialiser photosToHide
        if (this.newlyUploadedPhotos.length === 0) {
          this.photosToHide = this.allPhoto.map(photo => photo.id);
          console.log('Tous les IDs des photos √† masquer:', this.photosToHide);
        } else {
          // Mettre √† jour les photos dans l'avis avec les informations compl√®tes
          // On pourrait filtrer les photos compl√®tes ici si n√©cessaire
          console.log('Photos s√©lectionn√©es apr√®s upload:', this.newlyUploadedPhotos);
          console.log('IDs des photos √† masquer:', this.photosToHide);
        }
      },
      error: (err) => {
        console.error('Erreur lors de la r√©cup√©ration des photos:', err);
      }
    });
  }
 
  loadArticleDetails(id: number): void {
    this.isLoading = true;
    this.articleService.getById(id).subscribe({
      next: (data) => {
        this.article = data;
        this.isLoading = false;
        console.log("üìù D√©tails de l'article charg√©s:", this.article);
      },
      error: (err) => {
        this.errorMessage = "Erreur lors du chargement de l'article";
        this.isLoading = false;
        console.error("‚ùå Erreur:", err);
      }
    });
  }

  loadArticleAvis(articleId: number): void {
    this.isLoadingAvis = true;
    this.avisService.getAvisByArticleId(articleId).subscribe({
      next: (data) => {
        this.avis = data;
        this.isLoadingAvis = false;
        console.log("üí¨ Avis charg√©s:", this.avis);
        
        // Charger les informations utilisateur pour chaque avis si n√©cessaire
        this.avis.forEach(avis => {
          if (!avis.user || !avis.user.username) {
            this.loadUserForAvis(avis.id);
          }
        });
      },
      error: (err) => {
        console.error("‚ùå Erreur lors du chargement des avis:", err);
        this.isLoadingAvis = false;
      }
    });
  }

  // Fonctions pour la gestion du panier
  selectCouleur(couleur: Couleur): void {
    this.selectedCouleur = couleur;
    
    if (this.article && this.article.stocks?.length) {
      this.selectedPointures = this.article.stocks
        .filter(stock => stock.couleur.id === couleur.id)
        .map(stock => stock.pointure);
      
      this.selectedPointure = null; // R√©initialiser la s√©lection
    } else {
      this.selectedPointures = [];
    }
  }

  getUniqueColors(stocks: any[]): Couleur[] {
    const couleursUniques = [...new Set(stocks.map(stock => stock.couleur.id))];
    return couleursUniques.map(id => stocks.find(stock => stock.couleur.id === id)?.couleur);
  }

  ajouterAuPanier(): void {
    if (!this.article) {
      return;
    }
    
    if (!this.selectedCouleur) {
      alert("Veuillez s√©lectionner une couleur !");
      return;
    }
    
    if (!this.selectedPointure) {
      alert("Veuillez s√©lectionner une pointure !");
      return;
    }
    
    this.panierService.ajouterAuPanier(this.article, this.selectedCouleur, this.selectedPointure);
    alert(`${this.article.name} ajout√© au panier !`);
  }
  
  // Navigation entre les images
  nextImage(): void {
    if (this.article && this.article.photos && this.article.photos.length > 0) {
      this.currentImageIndex = (this.currentImageIndex + 1) % this.article.photos.length;
    }
  }
  
  prevImage(): void {
    if (this.article && this.article.photos && this.article.photos.length > 0) {
      this.currentImageIndex = (this.currentImageIndex - 1 + this.article.photos.length) % this.article.photos.length;
    }
  }
  
  // Retour √† la liste des articles
  retourListe(): void {
    this.router.navigate(['/articles']);
  }
  
  // M√©thodes d'upload de photos
  selectFiles(event: any): void {
    this.selectedFiles = event.target.files;
    this.currentFiles = Array.from(this.selectedFiles || []);
    this.progressInfos = this.currentFiles.map(file => ({ value: 0, fileName: file.name }));
    this.uploadMessage = '';
    this.uploadSuccess = false;
    this.uploadError = false;
  }

  uploadPhotos(): void {
    this.uploadMessage = '';
    this.uploadSuccess = false;
    this.uploadError = false;
    this.newlyUploadedPhotos = [];
    this.isUploading = true;
    
    if (this.selectedFiles && this.selectedFiles.length > 0) {
      const uploadObservables = Array.from(this.selectedFiles).map((file, index) => {
        return this.uploadFile(file, index);
      });

      // Utiliser forkJoin pour attendre que tous les fichiers soient t√©l√©charg√©s
      forkJoin(uploadObservables).subscribe({
        next: (responses) => {
          this.uploadSuccess = true;
          this.uploadMessage = 'Toutes les photos ont √©t√© t√©l√©charg√©es avec succ√®s.';
          this.selectedFiles = undefined;
          this.currentFiles = [];
          
          // R√©cup√©rer les photos depuis la base de donn√©es comme dans CreateArticleComponent
          this.getPhotos();
          
          this.isUploading = false;
        },
        error: (err) => {
          this.uploadError = true;
          this.uploadMessage = 'Une erreur est survenue lors du t√©l√©chargement des photos.';
          this.isUploading = false;
          this.cdr.detectChanges();
        }
      });
    } else {
      this.isUploading = false;
    }
  }

  uploadFile(file: File, index: number): any {
    return new Promise((resolve, reject) => {
      this.uploadService.upload(file).subscribe({
        next: (event: any) => {
          if (event.type === HttpEventType.UploadProgress) {
            this.progressInfos[index].value = Math.round(100 * event.loaded / event.total);
          } else if (event instanceof HttpResponse) {
            // Stocker uniquement les donn√©es essentielles pour identifier la photo plus tard
            const newPhoto: Photo = event.body;
            this.newlyUploadedPhotos.push({...newPhoto}); // Utiliser une copie pour √©viter les r√©f√©rences partag√©es
            
            console.log('Photo upload√©e:', newPhoto);
            resolve(event.body);
          }
        },
        error: (err: any) => {
          this.progressInfos[index].value = 0;
          this.uploadError = true;
          reject(err);
        }
      });
    });
  }
  
  // Fonctions pour le syst√®me d'avis
  ouvrirFormAvis(): void {
    if (!this.isLoggedIn()) {
      // Rediriger vers la page de connexion
      this.router.navigate(['/login'], { 
        queryParams: { returnUrl: `/detailArticle/${this.articleId}` } 
      });
      return;
    }
    
    // R√©initialiser le formulaire
    this.avisForm.reset();
    this.newlyUploadedPhotos = [];
    
    // Ouvrir le modal
    const modalElement = document.getElementById('avisModal');
    if (modalElement) {
      this.avisModal = new bootstrap.Modal(modalElement);
      this.avisModal.show();
    }
  }
  
  soumettreAvis(): void {
    // R√©cup√©rer √† nouveau l'ID du client au cas o√π
    const currentUserId = this.getCurrentClientId();
    console.log("currentUserId", currentUserId);
    
    if (this.avisForm.invalid || !this.articleId || !currentUserId) {
      return;
    }
    
    // V√©rifier et logger les photos avant soumission
    console.log("Photos disponibles pour l'avis:", this.newlyUploadedPhotos);
    
    // Cr√©er l'objet avis avec des copies des photos pour √©viter les probl√®mes de r√©f√©rence
    const avisData = {
      description: this.avisForm.value.description,
      note: this.avisForm.value.note,
      photos: [...this.newlyUploadedPhotos]
    };
    
    console.log("Donn√©es d'avis √† soumettre:", avisData);
    
    // Soumettre l'avis
    this.avisService.createAvis(avisData, currentUserId, this.articleId).subscribe({
      next: (response) => {
        console.log('Avis cr√©√© avec succ√®s:', response);
        
        // Fermer le modal
        if (this.avisModal) {
          this.avisModal.hide();
        }
        
        // Recharger les avis
        this.loadArticleAvis(this.articleId!);
        
        // Afficher un message de succ√®s
        alert('Votre avis a √©t√© publi√© avec succ√®s !');
      },
      error: (err) => {
        console.error('Erreur lors de la cr√©ation de l\'avis:', err);
        alert('Erreur lors de la publication de votre avis. Veuillez r√©essayer.');
      }
    });
  }
  
  // V√©rifier si l'utilisateur est l'auteur d'un avis
  isAvisAuthor(avisItem: any): boolean {
    return this.isLoggedIn() && this.currentClientId === avisItem.client?.id;
  }
  
  // Supprimer un avis
  supprimerAvis(avisId: number): void {
    if (confirm('√ätes-vous s√ªr de vouloir supprimer cet avis ?')) {
      this.avisService.deleteAvis(avisId).subscribe({
        next: () => {
          this.loadArticleAvis(this.articleId!);
          alert('Avis supprim√© avec succ√®s.');
        },
        error: (err) => {
          console.error('Erreur lors de la suppression de l\'avis:', err);
          alert('Erreur lors de la suppression de l\'avis. Veuillez r√©essayer.');
        }
      });
    }
  }
  
  togglePhotoSelection(photo: Photo): void {
    const index = this.newlyUploadedPhotos.findIndex(p => p.id === photo.id);
    if (index > -1) {
      // Si la photo est d√©j√† s√©lectionn√©e, la retirer
      this.newlyUploadedPhotos.splice(index, 1);
    } else {
      // Sinon, l'ajouter √† la s√©lection
      this.newlyUploadedPhotos.push(photo);
    }
    this.cdr.detectChanges(); // Forcer la mise √† jour de l'affichage
    console.log('Photos s√©lectionn√©es pour l\'avis:', this.newlyUploadedPhotos);
  }
  
  // Supprimer une photo upload√©e
  supprimerPhotoUploadee(index: number): void {
    this.newlyUploadedPhotos.splice(index, 1);
    this.cdr.detectChanges();
  }

  // Dans ArticleDetailComponent

// Ajouter une m√©thode pour r√©cup√©rer les infos utilisateur pour un avis sp√©cifique
loadUserForAvis(avisId: number): void {
  this.avisService.getUserFromAvis(avisId).subscribe({
    next: (userData) => {
      // Trouver l'avis dans le tableau et mettre √† jour les informations utilisateur
      const avisIndex = this.avis.findIndex(a => a.id === avisId);
      if (avisIndex !== -1) {
        this.avis[avisIndex].user = userData;
        this.cdr.detectChanges();
      }
      console.log(`Informations utilisateur charg√©es pour l'avis ${avisId}:`, userData);
    },
    error: (err) => {
      console.error(`Erreur lors du chargement des informations utilisateur pour l'avis ${avisId}:`, err);
    }
  });
}
}